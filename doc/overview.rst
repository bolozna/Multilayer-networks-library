Overview of the multilayer network library
==========================================

.. Mathematical definition
.. Everything is inherited from the MultilayerNetwork (e.g., efficient representation of multiplex networks, but still all the algorithms written for multilayer networks work for multiplex networks)


Computational efficiency
------------------------

One often wants to study large scale synthetic networks or big network data sets. In this type of situations the most important thing is to consider how the memory and time requirements of the data structures and the algorithms scale with the size of the network. This library is designed with these scaling requirements in mind. The average scaling in time and memory should typically be optimal for number of nodes, :math:`n`, number of layers, :math:`l`, and number of edges, :math:`e`. We typically consider that the number of aspects, :math:`d`, to be constant and not dependent on the size of the data. Note, however, that the current implementation is only in Python (the C++ version implementation is in the planning phase), and thus the constant factor in the memory and time consumption is typically fairly large.

The main data structure underlying the general multilayer network representation is a global graph :math:`G_M` implemented as dictionary of dictionaries. That is, the graph is a dictionary where for each node, e.g. :math:`(u,v,\alpha,\beta)`, is a key and values is another dictionary containing information about the neighbors of each node. Thus, the inner dictionaries have the neighboring nodes as keys and weigths of the edges connecting them as values. This type of structure ensures that the average time complexity of adding new nodes, removing nodes, querying for exitense of edges, or their weights, are all on average constant, and iterating over the neighbors of a node is linear. Further, the memory requirements in scale as :math:`\mathcal{O}(n+l+e)`, and are typically dominated by the number of edges in the network.

Multiplex networks are a special case of multilayer networks, and we could easily employ the same data structure as for the multilayer networks. There are few reason why we don't want to do that here. First, in multiplex networks we typically want to iterate over intra-layer links of a node in a single layer, and this would require one to go through all the inter-layer edges too if the multilayer network data structure was used. Second, in most cases we don't want to explicitely store all the inter-layer links. For example, when we have a multiplex network with categorical couplings which are of equal weight the number of inter-layer edges grows as :math:`\mathcal{O}(nl^2)`. In the multiplex network data structure in this library we only always store the intra-layer networks separately, and don't store the inter-layer edges explicitely but only generate them according to given rules when they are needed. This ensures that we can always iterate over the intra-layer edges in time which is linear to their number, and that having the inter-layer edges only requires constant memory (i.e. the memory to store the rule to generate them).
